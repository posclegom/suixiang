<!DOCTYPE.md>
.md xmlns="http://www.w3.org/1999/..md" xml:lang="zh-CN">
<head>
<meta http-equiv="Content-Type" content="text.md; charset=utf-8" />
<meta name="generator" content="Python script by program.think@gmail.com" />
<meta name="provider" content="program-think.blogspot.com" />
<link type="text/css" rel="stylesheet" href="../../css/program-think.css" />
<title>软件工程进阶之每日构建[1]：好处和优点 - 编程随想的博客</title>
</head>
<body>
<div id="main" style="width:100%;">
<h1><a href="../../index.md" title="回到首页">软件工程进阶之每日构建[1]：好处和优点</a></h1>
<div class="post-info"><span class="date-header">2009-02-16</span><a href="../../tags/E7BC96E7A88B.md" class="tag">编程</a> <a href="../../tags/E7BC96E7A88B.E8BDAFE4BBB6E5B7A5E7A88B.md" class="tag">编程.软件工程</a> </div>
<hr>
<div class="post">
　　上一个帖子“<a href="../../2009/02/daily-build-0-overview.md">软件工程进阶之每日构建[0]：概述</a>”提到说每日构建是一种很牛X的软件工程手段。本帖子就来说说它到底有多牛X。为了加深大伙儿的印象，我先来说一些陈年往事。<br />　　话说上世纪末，我还在一家小公司干活，并参与开发了一个C++的项目。当时公司的流程是：开发人员写好代码，自己编译好，丢给测试人员测试；测试人员如果发现bug，口头通知开发人员改；开发人员改好bug，再丢给测试人员测试<!--program-think-->......<br /><br />　　★案例1（开发的混乱）<br />　　有一天，开发组的小头目找来程序员甲。<br />　　>>小头目：你负责的XX功能完成了没有？<br />　　>>程序员甲：早做完啦！<br />　　>>小头目：那测试人员甲怎么说一直没看到XX功能？<br />　　>>程序员甲：不会吧！我去瞧瞧。<br />　　若干分钟后，程序员甲回来。<br />　　>>程序员甲：不好意思，编译好的EXE我只发给了测试人员乙，忘记发给测试人员甲了。<br />　　>>小头目：!@#$%^&amp;*（此处省略15字）<br /><br />　　★案例2（测试的混乱）<br />　　另一天刚上班。<br />　　>>测试人员甲：今天的XX.EXE怎么一运行就崩溃？<br />　　>>测试人员乙：有吗？我这儿好好的呀！<br />　　>>测试人员甲：真见鬼！我找开发问一下。<br />　　经过若干分钟打听，知道XX.EXE是程序员丙负责，于是找来程序员丙。<br />　　>>测试人员甲：为啥你做的XX.EXE一运行就崩溃？<br />　　>>程序员丙：有这回事？！让我看看你的环境。<br />　　程序员丙在测试人员甲的机器上研究了N刻钟后。<br />　　>>程序员丙：你是猪脑啊，你没有更新XXX.DLL，害我浪费这么长时间！<br />　　>>测试人员甲：你才是猪脑！我怎么知道XX.EXE会用到XXX.DLL？<br />　　然后两人开始对骂......<br /><br />　　★案例3（集成的混乱）<br />　　临近项目交付了，开发人员都在忙着改bug，测试人员都在忙着复测bug，没有人手准备安装包，于是安装包的制作一直拖到项目交付的前一天才开始搞。制作安装包本身倒是很快，半天就搞定。但是......<br />　　>>小头目：做好的安装包应该没什么问题吧？<br />　　>>测试人员丙：呃，这个，这个......好像装出来的软件没法运行，直接崩溃了。<br />　　>>小头目：偶的神啊！还愣着干嘛，快去查原因！！！今天不搞定大家不许回家！！！<br />　　然后开发和测试通力协作，经过艰苦卓绝的努力，到了午夜时分，终于发现：有个DLL是Debug版本......<br />　　有同学可能会问：为啥平时测试的时候没发现这个问题捏？因为平时团队里面都使用Debug版本，方便ASSERT断言。到了作安装包那天，照道理应该统一编译Release版本，但是有个家伙遗漏了，所以混了一个Debug版本的DLL在里面。等安装完运行程序时，该DLL动态加载失败，所以程序就崩溃鸟。<br /><br />　　我上面说的这些情形，到今天为止，还在很多公司内部上演。那为啥每日构建能搞定上面这些问题捏？且听我细细道来：<br /><br />　　★针对“开发的混乱”<br />　　对于每日构建的流程，开发人员只要负责提交代码到代码库中。不需要挨个给测试人员提供编译后的二进制文件。因此案例1的问题（漏给测试文件）迎刃而解。<br /><br />　　★针对“测试的混乱”<br />　　在开发阶段，由于测试拿到的程序都是自动编译出来的，因此保证了所有测试人员拿到的是统一的运行程序，并且这个程序和代码库中最新的代码是相对应的。<br />　　在测试阶段，每一个开发人员修复了Bug之后，都必须把改过的代码提交到代码库，测试人员才会拿到改过Bug的二进制程序。如果某个开发人员改了Bug但是不提交代码，那么在测试人员看来，相当于他的Bug一直没有改，因此他的Bug就一直不会被关闭。<br />　　所以案例2的情况也不会出现。<br /><br />　　★针对“集成的混乱”<br />　　对于每日构建来说，每天都会产生安装包（或者安装光盘的ISO镜像）。也就是说，从项目开始开发的那天起，每天都在进行集成（这就是传说中的<b>持续集成</b>）。因此，集成的问题，在一开始就会暴露出来，而不用等到项目后期。<br /><br />　　其实每日构建的好处除了上述三点（这三点我认为比较重要），还有其它很多，大伙儿可以自己再琢磨一下。<a href="../../2009/02/daily-build-2-prepare.md">后面一个帖子</a>，我把每日构建需要的准备工作介绍一下。<div class="blogger-post-footer">
</div>
<hr>
<div class="copyright">
<h4>版权声明</h4>
本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者<a href="mailto:program.think@gmail.com">编程随想</a>和本文原始网址：<br>
<a href="2009/02/daily-build-1-advantage.md">2009/02/daily-build-1-advantage.md</a>
</div>
</div>
</body>
<.md>
