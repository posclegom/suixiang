<!DOCTYPE.md>
.md xmlns="http://www.w3.org/1999/..md" xml:lang="zh-CN">
<head>
<meta http-equiv="Content-Type" content="text.md; charset=utf-8" />
<meta name="generator" content="Python script by program.think@gmail.com" />
<meta name="provider" content="program-think.blogspot.com" />
<link type="text/css" rel="stylesheet" href="../../css/program-think.css" />
<title>如何开展灰盒测试[4]：接口测试实战——测试跨主机的模块接口 - 编程随想的博客</title>
</head>
<body>
<div id="main" style="width:100%;">
<h1><a href="../../index.md" title="回到首页">如何开展灰盒测试[4]：接口测试实战——测试跨主机的模块接口</a></h1>
<div class="post-info"><span class="date-header">2010-12-26</span><a href="../../tags/E7BC96E7A88B.md" class="tag">编程</a> <a href="../../tags/E7BC96E7A88B.E8BDAFE4BBB6E5B7A5E7A88B.md" class="tag">编程.软件工程</a> <a href="../../tags/E7BC96E7A88B.E5BC80E6BA90E9A1B9E79BAE.md" class="tag">编程.开源项目</a> <a href="../../tags/E7BC96E7A88B.Python.md" class="tag">编程.Python</a> </div>
<hr>
<div class="post">
　　跨主机的交互方式，必然涉及到网络（为了防止爱抬杠的同学挑刺，事先声明：本节提及的网络，均是基于TCP/IP网络）。在TCP/IP协议栈的4个层次中（参见<a href="http://zh.wikipedia.org/zh/TCP/IP%E5%8D%8F%E8%AE%AE" target="_blank" rel="nofollow">这里</a>），模块间的交互方式主要是位于上面两层（传输层、应用层）。<br />　　有些软件系统，直接采用某种现成的应用层协议（比如HTTP）来进行跨主机的通讯。这时候，测试人员就只需关心该应用层协议，不用操心传输层是如何实现的。<br />　　还有一些软件系统，自己实现了某种专有的应用层协议。这种情况下，对测试人员的要求就比较高了——测试人员需要大致了解传输层的知识以及该专有应用协议的格式。（具体请看本帖的Socket这一节）<!--program-think--><br /><br /><h2>★基于Web接口的交互（HTTP协议）</h2><br />　　由于这几年B/S系统大行其道，而B/S系统，总是离不开HTTP协议，所以俺首先来介绍它。<br />　　在B/S系统中，服务端（也叫后端）总是会提供一些Web接口给客户端（前端）进行调用。这种调用总是基于HTTP协议来进行（HTTP协议的介绍，请看维基百科的<a href="http://zh.wikipedia.org/zh-cn/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="nofollow">这里</a>）。当你针对服务端进行灰盒测试，你需要模拟客户端的各种HTTP请求（既要包括合法的请求，也要包括各种非法的、无效的请求），然后再检验服务端返回的响应（Response）内容。如果响应内容不符合接口文档的约定，就表明该服务端模块出Bug了。<br />　　HTTP请求（Request），常用的主要是GET方式和POST方式。这两者的用途及区别，维基百科上已有，俺就不浪费口水了，直接说如何进行脚本编程。<br /><br /><h3>◇使用内置的标准模块</h3><br />　　在Python脚本中，内置了完善的模块（urllib和urllib2），以便于你操作HTTP协议。对于简单的使用，urllib就足够了。<br /><br />比如俺想用GET方式抓取Google的主页，只需如下3行代码：<font face="Courier New"><br />import urllib<br />f = urllib.urlopen("http://www.google.com/")<br />print f.read()</font><br /><br />如果想往某个Web接口POST数据，并得到服务端的返回内容，只需再增加1行代码（构造POST参数）：<font face="Courier New"><br />import urllib<br />params = urllib.urlencode({name1:value1, name2:value2})<br />f = urllib.urlopen("http://xxxx/xxxx", params)<br />print f.read()</font><br /><br />　　如果需要一些复杂点的功能（比如：操作cookie、使用带认证的proxy），urllib2就可以派上用场了。更多的使用细节，请看洋文的官方文档（<a href="http://docs.python.org/library/urllib..md" target="_blank" rel="nofollow">这里</a>和<a href="http://docs.python.org/library/urllib2..md" target="_blank" rel="nofollow">这里</a>）。<br /><br /><h3>◇使用cURL</h3><br />　　俺博客的老读者，或许记得俺在09年初写过的一个帖子——<a href="../../2009/03/opensource-review-curl-library.md" target="_blank">cURL(优秀的应用层网络协议库)</a>。看完这个帖子，你就能领会到：cURL是一个非常牛X的网络协议库，支持很多种网络协议（显然也包括HTTP）。这么牛X的一个开源库，自然会有不少编程语言对其进行包裹。下面俺把cURL相关的脚本语言及其开源项目列一个表格。如果你不喜欢用Python，或许可以改用俺列举的其它脚本语言。<br /><font face="Courier New"><br />　　语言/平台　　 开源项目<br />　　Python　　　　<a href="http://pycurl.sourceforge.net/" target="_blank" rel="nofollow">pycurl</a><br />　　Ruby　　　　　<a href="http://curb.rubyforge.org/" target="_blank" rel="nofollow">Curb</a><br />　　Perl　　　　　<a href="http://search.cpan.org/%7Ecrisb/WWW-Curl/Easy.pm.in" target="_blank" rel="nofollow">WWW::Curl::Easy</a><br />　　dotNet　　　　<a href="http://libcurl-net.sourceforge.net/" target="_blank" rel="nofollow">libcurl.NET</a><br /></font><br /><h2>★基于数据库的交互</h2><br />　　在现有软件系统的开发过程中，操作数据库也属于家常便饭。因此，聊完HTTP协议之后，就得来聊一下数据库的操作。眼下，大部分程序员都是远程操作数据库，所以俺把数据库的操作也归入“跨主机”交互方式。（其实本节的内容也适用于操作本机数据库）<br />　　在很多软件系统中，软件模块需要从数据库中读取数据或者把自己生成的数据存储到数据库中。因此，测试人员需要通过一些测试脚本，在数据库中制造测试数据，以作为软件模块的输入；或者在软件模块把数据保存到数据库之后，验证其输出的数据是否符合接口文档的约定。<br />   <br /><h3>◇跨数据库的接口</h3><br />　　所谓的“跨数据库的接口”，顾名思义，就是这种编程接口可以支持多种数据库产品。如果你没有其它特殊的要求（比如性能），俺建议尽量用这种方式操作数据库。这样的好处是，万一哪天数据库平台换了，你的测试脚本可以不用大改（甚至不改）。<br /><br />　　1、ODBC<br />　　ODBC是一种三跨（跨数据库、跨操作系统、跨编程语言）的数据库接口。大部分知名的数据库软件都支持ODBC方式访问。<br />　　Python有不止一个的ODBC开源项目，可以考虑用<a href="http://code.google.com/p/pyodbc/" target="_blank" rel="nofollow">PyODBC</a>或<a href="http://ceodbc.sourceforge.net/" target="_blank" rel="nofollow">ceODBC</a>。<br /><br />　　2、JDBC<br />　　对于搞Java开发的同学，应该很熟悉JDBC。不过很多人有一个误解，以为只有Java才可以进行JDBC编程。其实不然！自从前几年JVM开始效仿DotNet，支持多种编程语言之后，很多脚本语言也可以在JVM上跑起来了。比如Python（JVM上叫<a href="http://zh.wikipedia.org/zh-cn/Jython" target="_blank" rel="nofollow">Jython</a>）、Ruby（JVM上叫<a href="http://zh.wikipedia.org/zh-cn/JRuby" target="_blank" rel="nofollow">JRuby</a>）、<a href="http://zh.wikipedia.org/zh-cn/Groovy" target="_blank" rel="nofollow">Groovy</a>。作为测试人员，你也可以利用上述脚本语言，编写基于JDBC的数据库测试脚本。<br />   <br />　　3、ADO / ADO.Net<br />　　ADO / ADO.Net（以下简称ADO）是微软设计的跨数据库编程接口。既然是微软搞得，秉承其一贯风格，自然是不跨操作系统的。如果你所有的测试工作都在Windows平台上，也可以考虑用ADO来访问数据库。<br />　　如果要用Python进行ADO编程，可以考虑用PyWin32开源项目（官网在<a href="http://sourceforge.net/projects/pywin32/" target="_blank" rel="nofollow">这里</a>）。它是专门针对Windows平台的Python扩展，让Python可以很方便地调用各种Win32的API（包括ADO的API）。<br />　　你还可以使用基于dotNet平台之上脚本语言。比如<a href="http://zh.wikipedia.org/zh-cn/IronPython" target="_blank" rel="nofollow">IronPython</a>、<a href="http://zh.wikipedia.org/zh-cn/IronRuby" target="_blank" rel="nofollow">IronRuby</a>等。这些运行于DotNet之上的脚本语言，自然也就具有操作ADO的能力。<br /><br /><h3>◇特定数据库的接口</h3><br />　　前面已经提到“跨数据库的接口”有种种好处，那啥时候需要用特定数据库的接口捏？有时候，你需要使用某个数据库专有的某个特色功能，这时候，通用的数据库接口可能就搞不定了，你就需要用该数据库特定的编程接口来写脚本。当然，这种情况不是很多见。<br />　　下面，俺把几种常见数据库及其对应的Python开源项目列在如下表格中。<br /><font face="Courier New"><br />　　数据库　　　　 Python开源项目<br />　　Oracle　　　　<a href="http://cx-oracle.sourceforge.net/" target="_blank" rel="nofollow">cx_Oracle</a><br />　　SQL Server　　<a href="http://code.google.com/p/pymssql/" target="_blank" rel="nofollow">pymssql</a><br />　　DB2　　　　　　<a href="http://sourceforge.net/projects/pydb2/" target="_blank" rel="nofollow">pydb2</a><br />　　MySQL　　　　　<a href="http://mysql-python.sourceforge.net/" target="_blank" rel="nofollow">MySQL-Python</a><br />　　PostgreSQL　　<a href="http://initd.org/psycopg/" target="_blank" rel="nofollow">psycopg2</a><br />　　SQLite　　　　<a href="http://docs.python.org/library/sqlite3..md" target="_blank" rel="nofollow">（Python内置）</a><br /></font><br /><h3>◇关于Python的补充说明</h3><br />　　刚才介绍了多个操作数据库的Python开源项目。俺顺便补充一下：Python社区制定了一个<a href="http://www.python.org/dev/peps/pep-0249/" target="_blank">数据库操作的规范</a>。那些比较靠谱的数据库操作的模块，都会遵循该规范。因此，你只要熟悉了某一个模块，也就很容易熟悉其它模块。<br />   <br /><h2>★基于网络文件系统的交互（NFS）</h2><br />　　网络文件系统存在的目的，就是把跨主机的文件操作，伪装成本机的文件操作。所以，对NFS的灰盒测试，放到后面的帖子（主机内的跨进程交互方式）一起聊。<br /><br /><h2>★基于其它应用层协议的交互</h2><br />　　还有另外一些应用层的网络协议，其应用范围没有HTTP协议那么广，因此，Python没有把它纳入到内置的标准模块中。这时候，前面提到的PycURL就可以派上用场了。你只要安装一个PycURL，就可以搞定十几种应用层协议（FTP,FTPS,Gopher,SCP,SFTP,TFTP,TELNET,LDAP,LDAPS,IMAP,POP3,SMTP），非常之爽！<br />   <br /><h2>★基于Socket的交互</h2><br />　　前面提到，如果软件系统自己实现了专有的应用层协议，那测试人员进行灰盒测试时，就必须了解该专有协议的格式以及传输层的知识。在这种情况下，测试人员可能需要直接和Socket打交道。<br />　　Python内置了对socket的支持，Python官方的洋文介绍在<a href="http://docs.python.org/howto/sockets..md" target="_blank" rel="nofollow">这里</a>。Python的socket API和传统的伯克利套接字API很像，如果你之前写过C语言的socket程序，那搞定Python的socket程序肯定是不在话下滴。<br />　　但你千万别高兴得太早。用脚本来模拟软件模块之间的socket通讯，主要难点往往不在于socket，而在于专有协议本身。有些专有的通讯协议格式多变且复杂，有些虽然格式不太复杂，但是通讯双方交互的逻辑很复杂。因此，在socket层面进行灰盒测试，测试人员要多花精力在这方面。<br /><br />　　对“跨主机的模块接口”该如何进行灰盒测试，就介绍到这里。下一个帖子介绍“主机内跨进程的模块接口”该如何搞。<div class="blogger-post-footer">
</div>
<hr>
<div class="copyright">
<h4>版权声明</h4>
本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者<a href="mailto:program.think@gmail.com">编程随想</a>和本文原始网址：<br>
<a href="2010/12/grey-box-testing-4.md">2010/12/grey-box-testing-4.md</a>
</div>
</div>
</body>
<.md>
